A block cipher uses a symmetric key to encrypt data of fixed and very short length (the block size), such as 16 bytes for AES. In order to cope with data of arbitrary length, the cipher must be combined with a mode of operation.

Classic modes
![[Pasted image 20240407092826.png]]

- ECB -> semantically insecure
- CBC 
The method `encrypt()` (and likewise `decrypt()`) of a CBC cipher object expects data to have length multiple of the block size (e.g. 16 bytes for AES). You might need to use [`Crypto.Util.Padding`](https://pycryptodome.readthedocs.io/en/latest/src/util/util.html#module-Crypto.Util.Padding "Crypto.Util.Padding") to align the plaintext to the right boundary.

- CTR

This mode turns the block cipher into a stream cipher. The _keystream_ is generated by encrypting a sequence of _counter blocks_ with ECB.
A _counter block_ is exactly as long as the cipher block size (e.g. 16 bytes for AES). It consists of the concatenation of two pieces:
1. a fixed **nonce**, set at initialization.
	1. the value of the fixed nonce. It must be unique for the combination message/key. Its length varies from 0 to the block size minus 1. If not present, the library creates a random nonce of length equal to block size/2.
2. a variable **counter**, which gets increased by 1 for any subsequent counter block. The counter is big endian encoded.

The methods `encrypt()` and `decrypt()` of a CTR cipher object accept data of any length (i.e. padding is not needed).

- CFB = CBC + CTR
- OFB

Classic modes of operation such as CBC only provide guarantees over the _confidentiality_ of the message but not over its _integrity_. In other words, they don’t allow the receiver to establish if the ciphertext was modified in transit or if it really originates from a certain source.

The code in the previous section (CTR + HMAC) contains three subtle but important design decisions: the _nonce_ of the cipher is authenticated, the authentication is performed after encryption, and encryption and authentication use two uncorrelated keys. It is not easy to securely combine cryptographic primitives, so more modern cryptographic cipher modes have been created such as, the [OCB mode](https://pycryptodome.readthedocs.io/en/latest/src/cipher/modern.html#ocb-mode)
PROBLEMA: per ogni encrypt dovrei salvarmi oltre alla key anche il tag, MA quest ultimo cambia ad ogni encrypt anche con stessa chiave

